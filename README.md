Analyse: DynamicArray vs SinglyLinkedList1. Time ComplexityOperatieDynamicArray (Best / Worst)LinkedList (Best / Worst)Toevoegen aan begin$O(n) / O(n)$ (schuiven)$O(1) / O(1)$ (pointer verzetten)Toevoegen aan eind$O(1) / O(n)$ (resize)$O(n) / O(n)$ (geen tail pointer)Toegang via index$O(1) / O(1)$$O(1) / O(n)$ (moet traverseren)Verwijderen$O(1) / O(n)$$O(1) / O(n)$Toelichting Best/Worst CaseDynamicArray: De best case voor toevoegen is $O(1)$ als de interne array nog ruimte heeft. De worst case is $O(n)$ wanneer de array vol is en we moeten Resize().LinkedList: Toevoegen aan het begin is altijd $O(1)$ omdat we alleen de Head hoeven aan te passen. Toevoegen aan het eind is zonder Tail pointer altijd $O(n)$, omdat we de hele lijst moeten aflopen.2. Execution Time (Performance Test)In mijn tests met $N=50.000$ items was de LinkedList.AddFirst aanzienlijk sneller ($<10ms$) dan DynamicArray.Insert(0) ($>500ms$). Dit komt doordat de DynamicArray bij elke toevoeging aan het begin alle bestaande elementen één plek in het geheugen moet verschuiven.3. VerbetervoorstellenDynamicArray: Implementeer een 'Shrink' methode die de capaciteit halveert als de lijst voor minder dan 25% gevuld is. Dit bespaart geheugen.LinkedList: Voeg een _tail pointer toe. Hiermee wordt AddLast een $O(1)$ operatie in plaats van $O(n)$.Generics: Voeg IEnumerator ondersteuning toe zodat de lijsten gebruikt kunnen worden in een foreach loop.
